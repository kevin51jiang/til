<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>til / opaque types — Lee Byron</title>
    <meta property="og:url" content="https://leebyron.com/til/opaque-types/">
    <meta property="og:title" content="til / opaque types — Lee Byron">
    <meta property="og:description" content="One of my favorite features from Flow is opaque types. This allows a separation between interface and implementation that’s incredibly helpful as a type API designer, and a rare example of a “nominal type” in an otherwise “structural type” environment. Unfortunately, TypeScript still does not support this functionality.">
    <meta property="og:type" content="article">
    <meta property="article:author:first_name" content="Lee">
    <meta property="article:author:last_name" content="Byron">
    <meta property="article:published_time" content="2022-01-25T22:09:05.000-08:00">
    <meta property="article:modified_time" content="2022-08-21T04:52:11.000+00:00">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@leeb">
    <script type="application/ld+json">
{
  "@context": "https://schema.org/",
  "@type": "LearningResource",
  "name": "opaque types",
  "description": "One of my favorite features from Flow is opaque types. This allows a separation between interface and implementation that’s incredibly helpful as a type API designer, and a rare example of a “nominal type” in an otherwise “structural type” environment. Unfortunately, TypeScript still does not support this functionality.",
  "author": {
    "@type": "Person",
    "name": "Lee Byron",
    "url": "https://leebyron.com"
  },
  "url": "https://leebyron.com/til/opaque-types/",
  "datePublished": "2022-01-25T22:09:05.000-08:00",
  "dateModified": "2022-08-21T04:52:11.000+00:00",
  "keywords": "typescript",
  "isPartOf": "https://leebyron.com/til/",
  "license": "https://creativecommons.org/licenses/by/4.0/"
}
</script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://leebyron.com/til/opaque-types/">
    <link rel="shortcut icon" href="../assets/favicon.png">
    <link rel="stylesheet" href="../assets/style.css">
    <link rel="alternate" type="application/atom+xml" title="Reader Feed" href="https://leebyron.com/til/feed.xml">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-61714711-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-61714711-1');
    </script>
  </head>
  <body>
    <header>
      <a href="https://leebyron.com"><img src="../assets/logo.svg" alt="Lee Byron"></a>
    </header>
    <article>
      <h1>
        <a href="../">til</a><span>opaque types</span>
      </h1>
      <p>
        One of my favorite features from Flow is <a href="https://flow.org/en/docs/types/opaque-types/" target="_blank">opaque types</a>. This allows a separation between interface and implementation that’s incredibly helpful as a type API designer, and a rare example of a “nominal type” in an otherwise “structural type” environment. Unfortunately, TypeScript still does not support this functionality.
      </p>
      <ol start="1">
        <li>
          <p>
            I use this as a much simpler version of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" target="_blank">private fields</a> that doesn’t require a class interface and is scoped to a whole module rather than just a single class (fantastically helpful for a more functional programming style).
          </p>
        </li>
        <li>
          <p>
            This is a great way to generate “subtypes” of a primitive like a string or number, which is particularly useful for representing things like URLs, UUIDs, and other things which are string-like but not strings.
          </p>
        </li>
      </ol>
      <p>
        You can emulate this behavior in TypeScript by lying to the compiler. For example, let’s create a <code>UUID</code> type:
      </p>
      <pre data-code-block data-lang="typescript"><code><span data-line="1"><span style="color:#D32F2F;">export</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">type</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">UUID</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">=</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">string</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">&amp;</span><span style="color:#24292EFF;"> { [$uuid]</span><span style="color:#D32F2F;">:</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">true</span><span style="color:#24292EFF;"> }</span>
</span><span data-line="2"><span style="color:#D32F2F;">declare</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">const</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">$uuid</span><span style="color:#D32F2F;">:</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">unique</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">symbol</span>
</span><span data-line="3">
</span><span data-line="4"><span style="color:#D32F2F;">export</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">function</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">isUUID</span><span style="color:#24292EFF;">(value</span><span style="color:#D32F2F;">:</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">unknown</span><span style="color:#24292EFF;">)</span><span style="color:#D32F2F;">:</span><span style="color:#24292EFF;"> value </span><span style="color:#D32F2F;">is</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">UUID</span><span style="color:#24292EFF;"> {</span>
</span><span data-line="5"><span style="color:#24292EFF;">  </span><span style="color:#D32F2F;">return</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">uuid</span><span style="color:#6F42C1;">.validate</span><span style="color:#24292EFF;">(value)</span>
</span><span data-line="6"><span style="color:#24292EFF;">}</span>
</span><span data-line="7">
</span><span data-line="8"><span style="color:#D32F2F;">export</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">function</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">createUUID</span><span style="color:#24292EFF;">()</span><span style="color:#D32F2F;">:</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">UUID</span><span style="color:#24292EFF;"> {</span>
</span><span data-line="9"><span style="color:#24292EFF;">  </span><span style="color:#D32F2F;">return</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">uuid</span><span style="color:#6F42C1;">.v4</span><span style="color:#24292EFF;">() </span><span style="color:#D32F2F;">as</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">UUID</span>
</span><span data-line="10"><span style="color:#24292EFF;">}</span>
</span></code></pre>
      <p>
        This introduces the type <code>UUID</code> which you can use anywhere you use a string, but you can also write functions that accept only a <code>UUID</code> and not just any string.
      </p>
      <p>
        This works by telling TypeScript that there exists a variable called <code>$uuid</code> that is a <a href="https://www.typescriptlang.org/docs/handbook/symbols.html#unique-symbol" target="_blank">unique symbol</a> (the result of calling <code>Symbol()</code>) and that the type <code>UUID</code> is both a <code>string</code> and (<code>&amp;</code>) an object with a required property of that unique symbol<a href="#fn:why" id="fn:why.ref" data-footnote-ref aria-label="note"><sup>1</sup></a>. However none of this exists at runtime, there is no variable or unique symbol, so there’s no way of actually creating a <code>UUID</code> type outside of casting, which we only do in this bit of library code.
      </p>
      <p>
        Perhaps you don’t actually want to expose that <code>UUID</code> is implemented as a <code>string</code>, just remove the <code>string &amp;</code>:
      </p>
      <pre data-code-block data-lang="typescript"><code><span data-line="1"><span style="color:#D32F2F;">export</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">type</span><span style="color:#24292EFF;"> </span><span style="color:#6F42C1;">UUID</span><span style="color:#24292EFF;"> </span><span style="color:#D32F2F;">=</span><span style="color:#24292EFF;"> { [$uuid]</span><span style="color:#D32F2F;">:</span><span style="color:#24292EFF;"> </span><span style="color:#1976D2;">true</span><span style="color:#24292EFF;"> }</span>
</span></code></pre>
      <p>
        This version cannot be used where a <code>string</code> is expected, even though it’s still a string value at runtime.
      </p>
      <p>
        This works surprisingly well, but there are shortcomings:
      </p>
      <ul>
        <li>
          <p>
            Errors are not specifically helpful. Provide the wrong value where <code>UUID</code> is expected and see the details of this hack exposed.
          </p>
        </li>
        <li>
          <p>
            This pattern is a bit inscrutable compared to Flow’s clearer explicit syntax. Don’t forget to include a comment explaining what this does.
          </p>
        </li>
        <li>
          <p>
            There’s still no concept of “module private” fields without going around the type compiler yet again.
          </p>
        </li>
        <li>
          <p>
            (As of TS v4.5) Equality checks require explicit typecasts. For example <code>userEmail === &quot;admin@site.co&quot;</code> will fail tsc with “This condition will always return false”. This example can be resolved with the typecast <code>(&quot;admin@site.co&quot; as Email)</code>. This should ideally not be necessary since the intent is to define a subtype, which should be comparable to the supertype.
          </p>
        </li>
      </ul>
      <p>
        More examples of where opaque types are useful:
      </p>
      <ul>
        <li>
          <p>
            <code>URL</code>, <code>Email</code>, <code>Username</code>, <code>ID</code> or anything else you might want to validate before using and offer a guarantee that if you have a value of that type, it has been validated.
          </p>
        </li>
        <li>
          <p>
            HTML sanitization, to type a string which has been HTML sanitized, while having unsafe functions that accept only sanitized strings.
          </p>
        </li>
        <li>
          <p>
            Subtypes of number, like integers or positive values.
          </p>
        </li>
        <li>
          <p>
            Opaque types for numeric or string database IDs which may be used alongside other strings or numbers.
          </p>
        </li>
        <li>
          <p>
            Unique types for overlapping identifiers such as classic MySQL auto increments that you’d hate to mix up, like <code>UserID</code> and <code>MessageID</code>.
          </p>
        </li>
      </ul>
      <p>
        I’d still love to see explicit support for this long-loved feature from Flow built into TypeScript, but this technique works reasonably well despite the shortcomings.
      </p>
      <section data-footnotes aria-label="footnotes">
        <ol>
          <li id="fn:why">
            <p>
              There are variants of this technique, a common alternative being <code>{_brand: typeof $uuid}</code> but I like this one the best for a couple reasons. I don’t like the IDE showing <code>._brand</code> in the typeahead completion; it will not show a symbol property. I find it slightly more helpful to <a href="https://www.typescriptlang.org/play?#code/PTAEFkE9QBwJwKYDMF0QE1AFwQYwBYB2AlgI4CuCAUAgB4wD2cW2kMCoAqpwJIAioALygAzljjFCAc1AAyUAG9QAbQAk5csXQBdAFzY4lUAF8q6PABsAholC4GhMaHWb0+8iQocRkALYAjBgszSxsOJA9cLGIHUGIRbn4ACgA3KwtKd0IAa0IGAHdCAEp9NIyOeK5ePioqEFAAQTsGX19Y9Jw4QitolOo6RmZWdlAAUV8rYgshUXFJGXklAH0l-zgrQnQV-Sw2BAYkZwQJqZMQ3Gtbe0cWVWPJiyyyIx8AoPPL8Mjo2Pjxh9S6UyoA8uQKxVKQIqIjGJ2CdTAAGEWjAwth8BxUHAmKBfAgRCIrFJ8VRrk48lgGok+PpqTMAOQARgATABmemkhzkhiUwj-Kb6fnTYRMtn0oA" target="_blank">see the name of the symbol shown</a> when encountering an error .
            </p>
            <a href="#fn:why.ref" data-footnote-backref aria-label="return">↩</a>
          </li>
        </ol>
      </section>
    </article>
    <footer>
      <div class="linkedlist">
        <a href="../staff-eng-archetypes/" class="prev">staff eng archetypes</a><a href="../numeric-string-type/" class="next">numeric string type</a>
      </div>
      <div class="license" xmlns:cc="http://creativecommons.org/ns" xmlns:dct="http://purl.org/dc/terms/">
        This <a property="dct:title" rel="cc:attributionURL" href="https://leebyron.com/til/opaque-types/">til</a> was created <span property="dct:created" content="2022-01-25T22:09:05.000-08:00">Tue, Jan 25, 2022, 10:09 PM</span> ⸱ <a href="https://raw.githubusercontent.com/leebyron/til/main/entries/opaque%20types.md" target="_blank">raw</a> ⸱ <a href="https://github.com/leebyron/til/edit/main/entries/opaque%20types.md#L8" target="_blank">edit</a><br>© <span rel="dct:dateCopyrighted">2022</span> <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://leebyron.com">Lee Byron</a> ⸱ licensed under <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank" rel="cc:license license noopener noreferrer">CC BY 4.0<img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" aria-hidden="true"><img src="https://mirrors.creativecommons.org/presskit/icons/by.svg" aria-hidden="true"></a> ⸱ <a href="https://leebyron.com/til/feed.xml" rel="alternate feed" type="application/atom+xml">feed</a>
      </div>
    </footer>
  </body>
</html>